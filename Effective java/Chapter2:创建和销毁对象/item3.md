# Item 3：用私有构造器或者枚举类型强化Singleton属性
单例模式所知的有饿汉式、懒汉式，最终通过静态方法提供，饿汉式也可以直接通过公有静态变量提供。

## 注意点：

### 1、反射攻击：
私有构造器通过反射机制可以调用并创建对象，因此应该在第二次以后调用时抛出异常抵御攻击。

### 2、比较通过公有静态变量提供还是静态工厂方法提供的优劣:
公有静态变量提供，可以清楚看到这个类是单例的，静态域是final的，清晰；
而静态工厂方法提供优点就是灵活，它可以不影响客户端调用的前提下，修改内部实现，可能需求变动导致我们并不想实现单例模式，修改静态方法内的代码即可。

### 3、（重点）序列化的影响：
仅仅实现Serializabel是不足以防止序列化对单例的影响，如果类内不加上readResolve()，每次反序列化一个序列化的实例时，都会重新创建一个新的实例，生成新的单例对象。
```Java
private Object readResolve(){
    return INSTANCE; 
}
```
[关于序列化破坏单例详解](http://www.importnew.com/18030.html)

### 4、枚举类型可以解决第3点的问题
枚举实现相当于提供一个公有的静态实例，自身实现了序列化，并防止多次实例化，并且不存在序列化和反射的破坏，是实现单例的最有选择。但是具体到项目中，枚举类型还是只适合轻量级的单例实现。

#### 总结：

第1、3点现实开发中需要注意但并不常见，第2点通过也是通过静态工厂方法提供更加灵活，第4点，能启发的是实际开发中多考虑枚举的使用，枚举的好处是项目可以减少很多潜在的问题,且更加清晰简洁。